/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package _streams_intro;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.Random;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class App {

    public static void main(String[] args) {

        var temps = Arrays.asList(99, 100, 101, 103, 104);

        Long count = temps.stream()
                .peek(System.out::println)
                .filter(temp -> temp > 100)
                .peek(System.out::println)
                .count();

        System.out.println(count);

        Random random = new Random();
        Supplier<Integer> intSup = () -> random.nextInt();

        // Stream<Integer> intStream = Stream.generate(intSup);
        Stream<Integer> integerStream = Stream.iterate(2, n -> n + 2)
                .limit(10);

        integerStream.forEach(System.out::println);

        String[] names = { "Saad", "Saud", "Khan", "Blueberry", "Dream", "Duplicate", "Duplicate" };
        Supplier<Stream<String>> streamSupplier = () -> Arrays.stream(names);

        Stream<String> nStream1 = streamSupplier.get();

        nStream1.filter((String string) -> string.length() > 4)
                .forEach(System.out::println);

        Stream<String> nStream2 = streamSupplier.get();

        nStream2
                .peek((s) -> System.out.println("before:\t" + s))
                .distinct()
                .forEach(System.out::println);

        Stream<String> nStream3 = streamSupplier.get();

        nStream3
                .map((s) -> "Prepend:\t" + s)
                .forEach(System.out::println);

        List<String> sList1 = Arrays.asList("List1:1", "List1:2");
        List<String> sList2 = Arrays.asList("List1:1", "List1:2");

        Stream<List<String>> soList = Stream.of(sList1, sList2);

        soList
                .flatMap(l -> l.stream())
                .forEach(System.out::println);

        Stream<String> nStream4 = streamSupplier.get();
        nStream4
                .sorted()
                .forEach(System.out::println);

        Stream<String> nStream5 = streamSupplier.get();
        nStream5
                .filter(s -> s.startsWith("B"))
                .forEach(System.out::println);

        // primitive streams
        int[] intArr = { 1, 2, 4, 5, 6 };
        double[] doubleArr = { 1.1f, 2.2f, 3.3f, 4.4f };
        long[] longArr = { 1L, 2L, 3L, 4L };

        IntStream intStream = Arrays.stream(intArr);
        DoubleStream doubleStream = Arrays.stream(doubleArr);
        LongStream longStream = Arrays.stream(longArr);

        intStream.forEach(System.out::println);
        doubleStream.forEach(System.out::println);
        longStream.forEach(System.out::println);

        DoubleStream randomStream = DoubleStream.generate(() -> Math.random());

        randomStream
                .limit(10)
                .forEach(System.out::println);

        Consumer<Object> print = System.out::println;

        Integer[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        int[] numsPrimitive = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        Supplier<Stream<Integer>> intStreamSupplier = () -> Arrays.stream(nums);
        Supplier<IntStream> intPrimitiveStreamSupplier = () -> Arrays.stream(numsPrimitive);

        IntStream npStream1 = intPrimitiveStreamSupplier.get();

        OptionalDouble np1Avg = npStream1.average();

        if (np1Avg.isEmpty()) {
            print.accept("np1Avg was empty!");
        } else {
            print.accept("np1Avg was Present:\t" + np1Avg.isPresent());
        }

        print.accept(np1Avg);

        OptionalInt intOpt = OptionalInt.of(1);

        Optional<Integer> integerOpt = Optional.of(1);
        Optional<String> stringOpt1 = Optional.of(new String("AAA"));
        Optional<String> stringOpt2 = Optional.of("BBB");

        Optional<Integer> varOpt1 = Optional.empty();

        varOpt1.ifPresent(o -> System.out.println("opt1:\t" + o));

        Optional<Integer> varOpt2 = Optional.of(23);

        varOpt2.ifPresent(o -> System.out.println("opt2\t" + o));

        Optional<Integer> varOpt3 = Optional.ofNullable(25);
        Optional<Integer> varOp4 = Optional.ofNullable(null);

        Stream<String> parallelFarmAnim = List.of("sheep", "pig", "chicken")
                .parallelStream();

        Stream<String> parallelHouseAnim = Stream.of("cat", "dog", "turtle")
                .parallel();

        int sum = Stream.of(10, 20, 30, 40, 50, 60)
                .mapToInt(Integer::intValue)
                .sum();

        System.out.println("Sum == " + sum);

        // OrderedSerialStreams();
        ParallelStreams();

        ParallelReducton();


        var namesArr = Stream.of("Saad", "Saud", "Jaan")
            .parallel();

        ConcurrentMap<Character,String> map =
            namesArr.collect(Collectors.toConcurrentMap(
                        name -> name.charAt(0),
                        name -> name,
                        (name1, name2) -> name1 + ", " + name2
                        ));
        System.out.println(map);
        System.out.println(map.getClass());

    }

    public static void ParallelReducton() {
        int sum = Stream.of(1, 2, 3, 4, 5)
                .parallel()
                .reduce(0,
                        (a, b) -> {
                            System.out.println("a:\t" + a + "\tb:\t" + b + "\ta-b:\t" + (a - b));
                            return a - b;
                        },
                        (s1, s2) -> {
                            System.out.println("s1:\t" + s1 + "\ts2:\t" + s2 + "\ts1-s2:\t" + (s1 - s2));
                            return s1 - s2;
                        }

                );

        System.out.println("sum:\t" + sum);
    }

    public static void ParallelStreams() {
        long startTime = System.currentTimeMillis();

        List.of(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
                .parallelStream()
                .map(App::delayedAction)
                .forEach(System.out::println);

        long deltaTime = (System.currentTimeMillis() - startTime) / 1000;
        System.out.println("Ordered Serial deltaTime:\t" + deltaTime);
    }

    public static void OrderedSerialStreams() {
        long startTime = System.currentTimeMillis();

        List.of(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
                .stream()
                .map(App::delayedAction)
                .forEach(System.out::println);

        long deltaTime = (System.currentTimeMillis() - startTime) / 1000;
        System.out.println("Ordered Serial deltaTime:\t" + deltaTime);
    }

    public static int delayedAction(int val) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return val;
    }
}
