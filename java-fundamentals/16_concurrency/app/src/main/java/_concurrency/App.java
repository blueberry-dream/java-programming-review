/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package _concurrency;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class App {

    public static void main(String[] args) {
        // MyThread myThread1 = new MyThread();
        // myThread1.start();

        // System.out.println("Hello from main thread:\t" +
        // Thread.currentThread().getId());
        //
        // MyRunnable myRunnable1 = new MyRunnable();
        // Thread thread = new Thread(myRunnable1);
        // thread.start();
        //
        // Runnable lambdaRunnable = () -> System.out.println("Hello from my thread:\t"
        // + Thread.currentThread().getId());
        // Thread thread2 = new Thread(lambdaRunnable);
        // thread2.start();

        Thread t = new Thread(() -> {
            try {
                System.out.println("Starting another thread");
                System.out.println("Thread #" + Thread.currentThread().getId() + " will sleep for 2000ms");
                Thread.sleep(2000);
                System.out.println("Yawn, I'm awake");
            } catch (Exception e) {
                e.printStackTrace();
            }
            ;
        });

        t.start();

        try {
            ExampleAtomicInteger.main(new String[0]);
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            System.out.println("Main thread will be waiting for t1 to finish");

            t.join();

            System.out.println("Main thread continues");
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("This is sync\tCounter::incrementCounter");

        Thread t3 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                Counter.syncIncrementCounter();
            }
        });

        Thread t4 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                Counter.syncIncrementCounter();
            }
        });

        try {
            t3.start();
            t4.start();

            t3.join();
            t4.join();
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("Counter value:\t" + Counter.counter);

        System.out.println("This is nonsync\tCounter::incrementCounter");
        Counter.counter = 0;

        for (int i = 0; i < 10; i++) {
            new Thread(Counter::incrementCounter).start();
        }

        System.out.println("Counter value:\t" + Counter.counter);

        // System.out.println("LockCounter");
        // for (int i = 0; i < 10; i++) {
        // new Thread(LockCounter::incrementCounter).start();
        // }

        for (int i = 0; i < 10; i++) {
            VoteCounter.main(new String[0]);
        }

        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(5000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return "result";
        });

    }

    private static class Counter {
        static int counter = 0;

        static void incrementCounter() {
            int current = counter;
            System.out.println("Before:\t" + counter + "\tCurrent Thread:" + Thread.currentThread().getId());

            counter = current + 1;
            System.out.println("After:\t" + counter);

        }

        static synchronized void syncIncrementCounter() {
            int current = counter;
            System.out.println("Before:\t" + counter + "\tCurrent Thread:" + Thread.currentThread().getId());

            counter = current + 1;
            System.out.println("After:\t" + counter);
        }
    }

    private static class MyRunnable implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello from my thread:\t" + Thread.currentThread().getId());
        }
    }

    private static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello from My Thread!");
        }
    }

    private static class ExampleAtomicInteger {
        private static AtomicInteger counter = new AtomicInteger(0);

        public static void main(String[] args) throws InterruptedException {
            Thread t1 = new Thread(() -> {
                for (int i = 0; i < 1000; i++) {
                    counter.getAndIncrement();
                }
            });

            Thread t2 = new Thread(() -> {
                for (int i = 0; i < 1000; i++) {
                    counter.getAndIncrement();
                }
            });

            t1.start();
            t2.start();
            t1.join();
            t2.join();
            System.out.println("Counter value:\t" + counter);
        }
    }

    private static class LockCounter {
        static final int MAX_RETRIES = 50;
        static int counter = 0;
        static Lock lock = new ReentrantLock();

        static void incrementCounter() {
            int retryCounter = 0;

            while (retryCounter < MAX_RETRIES) {
                if (lock.tryLock()) {
                    try {
                        int current = counter;
                        System.out
                                .println("Before:\t" + counter + "\tCurrentThread:\t" + Thread.currentThread().getId());
                        counter = current + 1;
                        System.out.println("After:\t" + counter);
                    } finally {
                        lock.unlock();
                    }
                } else {
                    System.out.println("Thread didn't get the lock");
                }

                retryCounter++;

                try {
                    Thread.sleep(100);
                } catch (Exception e) {
                    System.out.println("Retry interrupted:\t" + e.getMessage());
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        }
    }

    private static class VoteCounter {
        public static void main(String[] args) {
            ExecutorService executor = Executors.newSingleThreadExecutor();

            for (int i = 0; i < 10; i++) {
                int voteId = i;
                executor.execute(() -> {
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println("Vote:\t" + voteId + "\tcounted by\t" + Thread.currentThread().getId());
                });
            }

            executor.shutdown();
        }
    }
}
